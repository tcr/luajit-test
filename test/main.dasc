// Includes
#include <stdint.h>
#include <stdio.h>
#include <assert.h>
#include <dasm_proto.h>
#include <dasm_thumb.h>

// Most basic DynASM JIT; generates a trivial function that
// returns a given value, and executes it.

// DynASM directives.
|.arch thumb
|.actionlist actions

// This define affects "|" DynASM lines.  "Dst" must
// resolve to a dasm_State** that points to a dasm_State*.
#define Dst &state


int cmp (int n);

static void jit_init (dasm_State** state)
{
	printf("# JIT_INIT.\n");
	dasm_init(state, 1);
	dasm_setupglobal(state, (void **)malloc(32*sizeof(void *)), 32);
	dasm_setup(state, actions);
	assert(state != 0);
}

static void* jit_build (dasm_State** state, size_t* size)
{
	printf("# JIT_LINK.\n");
	// Link the code and write it to executable memory.
	int dasm_status = dasm_link(state, size);
	assert(*size != 0);
	assert(dasm_status == DASM_S_OK);
	void *code = calloc(1, *size);

	printf("# JIT_ENCODE.\n");
	dasm_encode(state, code);
	dasm_free(state);
	return code;
}

static int jit_compare (void* fn, void* code, size_t size)
{
	printf("# JIT_COMPARE (%d words):", size/2);
	for (int i = 0; i < size/2; i++) {
		if (((uint16_t*) code)[i] != ((uint16_t*) fn)[i]) {
			printf(" failed! word %d/%d: %04x isn't %04x\n", i+1, (size/2), ((uint16_t*) code)[i], ((uint16_t*) fn)[i]);
			printf("not ok\n");
			return 1;
		}
	}
	printf(" succeeded.\n");
	printf("ok\n");
	return 0;
}

static void jit_dump (void* code, size_t size)
{
	printf("# JIT_DUMP\n");
	// Dump generated code.
	for (int i = 0; i < size/2; i++) {
		printf(";;; %04x\n", ((uint16_t *) code)[i]);
	}
}

static void jit_free (void *code)
{
	printf("# JIT_DONE.\n\n");
	free(code);
}

#define TEST_JIT(A, T, ASM) \
void A ## _jit (void) \
{ \
	dasm_State *state; \
	size_t size = 0; \
	void* code; \
\
	printf("# TEST [%s]\n", #A); \
	A ## _test(A); \
	jit_init(&state); \
\
 	ASM; \
\
	code = jit_build(&state, &size); \
	if (jit_compare((void*) ((uint32_t) A - 1), code, size) != 0) \
		jit_dump(code, size); \
	printf("# JIT TEST.\n"); \
	A ## _test(((T) (code+1))); \
	jit_free(code); \
}

#define COMPARE_JIT(A, REALASM, ASM) \
void A (void) \
{ \
	REALASM; \
} \
void A ## _jit (void) \
{ \
	dasm_State *state; \
	size_t size = 0; \
	void* code; \
\
	printf("# COMPARE [%s]\n", #A); \
	jit_init(&state); \
\
 	ASM; \
\
	code = jit_build(&state, &size); \
	volatile uint32_t ptr = (uint32_t) A; \
	if (jit_compare((void*) (ptr - 1), code, size) != 0) \
		jit_dump(code, size); \
	jit_free(code); \
}













int fib (int n)
{
	int i = 2;
	int f1 = 0;
	int f2 = 1;
	int fn = 0;
	for (i = 2; i < n; i++) {
		fn = f1 + f2;
		f1 = f2;
		f2 = fn;
	}
	return fn;
}

void fib_test (int (*fn)(int))
{
	assert(fn(10) == 34);
	assert(fn(4) == 2);
	assert(fn(0) == 0);
	assert(fn(3) == 1);
}

TEST_JIT(fib, int (*)(int),
{
	| push {r4}
	| cmp r0, #2
	| ble >2
	| movs r2, #1
	| movs r4, #0
	| movs r3, #2
	|1:
	| adds   r1, r4, r2
	| adds  r3, #1
	| cmp r3, r0
	| beq >3
	| mov r4, r2
	| mov r2, r1
	| b <1
	|2:
	| mov r1, #0
	|3:
	| mov r0, r1
	| ldr r4, [sp], #4
	| bx  lr
	| nop
})


int cmp (int n)
{
	if (n > 5) {
		return 1;
	}
	return 0;
}

void cmp_test (int (*fn)(int))
{
	assert(fn(1) == 0);
	assert(fn(5) == 0);
	assert(fn(10) == 1);
}

TEST_JIT(cmp, int (*)(int),
{
	// The run-time value of C variable "num" is substituted
  	// into the immediate value of the instruction.
  	|.type num, int, r0
	| cmp num, #5
	| ite le
	| movle r0, #0
	| movgt r0, #1
	| bx  lr
	| nop
})



int mul (int a, int b)
{
	__asm__ (
	"mul.w r0, r1, r0\n\t"
	);
	// return a * b;
}

void mul_test (int (*fn)(int, int))
{
	assert(fn(2, 3) == 6);
	assert(fn(4, 12) == 48);
}

TEST_JIT(mul, int (*)(int, int),
{
	| mul.w r0, r1, r0
	| bx    lr
	| nop
})







COMPARE_JIT(arith,
__asm__ (
	"add.w r2, r3, #1\n\t"
	"add.w r2, r3, r4\n\t"
	"adds.w r2, r3, #1\n\t"
	"adds.w r2, r3, r4\n\t"
	"mul.w r0, r1, r0\n\t"
	"mul.w r2, r3, r2\n\t"
	"mov r4, r2\n\t"
	"subs r0, r1, #2\n\t"
	"sub r0, r0, #8\n\t"
	"add r1, r2, r3, lsl #2\n\t"
	"sub r0, r2, #0x20000\n\t"
	"sub r6, r11, #0x20000\n\t"
), {
	| add.w r2, r3, #1
	| add.w r2, r3, r4
	| adds.w r2, r3, #1
	| adds.w r2, r3, r4
	| mul.w r0, r1, r0
	| mul.w r2, r3, r2
	| mov r4, r2
	| subs r0, r1, #2
	| sub r0, r0, #8
	| add r1, r2, r3, lsl #2
	| sub r0, r2, #0x20000
	| sub r6, r11, #0x20000
})

int REGS_LSL = 24;


COMPARE_JIT(regs,
__asm__ (
	"ldr r3, [r3, #4]\n\t"
	"ldr r3, [r3, #5]\n\t"
	"ldr r3, [r4, #-4]\n\t"
	"sub r0, r0, r1, lsl #5\n\t"
	"sub r0, r0, r1, lsl #24\n\t"
	"sub r0, r0, r1, lsl #24\n\t"
), {
	| ldr r3, [r3, #4]
	| ldr r3, [r3, #5]
	| ldr r3, [r4, #-4]
	| sub r0, r0, r1, lsl #5
	| sub r0, r0, r1, lsl #24
	| sub r0, r0, r1, lsl #REGS_LSL
})



typedef struct {
	uint8_t number;
} simple_t;

void struct_jit()
{
	dasm_State *state;
	simple_t a = { 0 };
	simple_t* ptr = &a;
	ptr->number = 5;

    |.type a,		simple_t,	r0
	| ldr r0, a->number
}



int SOMETHING = 1;
int SOMETHING2 = 0x2C002C;

COMPARE_JIT(immtest,
__asm__ (
	"add.w r0, r0, #1\n\t"
	"add.w r0, r0, #0x2C002C\n\t"
), {
	| add.w r0, r0, #SOMETHING
	| add.w r0, r0, #SOMETHING2
})



void sub_neg ()
{
__asm__ (
	"add r6, #-255"
);
}




int main ()
{
	printf("# START.\n\n");

	fib_jit();
	cmp_jit();
	mul_jit();
	arith_jit();
	struct_jit();
	immtest_jit();
	regs_jit();

	printf("# FINISHED.\n");

	return 0;
}
